---
title: "xv6-Lab-1"
date: 2024-07-13T15:22:04+02:00
draft: false
---

ä¸­æ–‡åœ¨ä¸‹é¢ğŸ‘‡

## Introduction

[xv6](https://github.com/mit-pdos/xv6-public) is an educational operating system used in [MIT's course S6.081](https://pdos.csail.mit.edu/6.S081/2021/index.html) on operating systems. It is a simplified OS that runs only on x86 architecture. This blog aims to document the process of completing [Lab 1](https://pdos.csail.mit.edu/6.S081/2021/labs/util.html) and highlight some key concepts.

![All passed!](/xv6-1.png)

## Sleep

The first task is to implement the `sleep` command in xv6. This is not a system call but a bash command in xv6. The implementation involves calling the `sleep()` system call.

This task is relatively simple but is noteworthy for revealing the system call process in xv6. The header file exposes the interface for the `sleep()` system call. By looking at the `sys_sleep()` function in the `sysproc.c` file, one can see the specific implementation of the system call. The connection between the user-space function and the kernel function is established through a piece of **RISC-V** assembly:

```assembly
.global sleep
sleep:
 li a7, SYS_sleep
 ecall
 ret
```

This assembly code places the system call number `SYS_sleep` into the `a7` register, then invokes the `ecall` instruction to trigger the system call.

The `sleep()` system call also involves the concept of **ticks**. Ticks are a crucial topic in OS. In xv6, ticks represent the interval between two clock interrupts. In Linux, ticks are set as a macro definition, often defaulting to 100, meaning the clock ticks 100 times per second, analogous to frequency in physics. When performing benchmarks, functions like `times()` return time in ticks. Increasing the tick rate improves clock precision but also raises observation overhead. Thus, programmers need to choose an appropriate tick rate for their applications, commonly referred to as **Software Clock**. For high-precision observations, Windows uses the QPC (QueryPerformanceCounter) function, while Linux uses `clock_gettime()`, with the former providing microsecond precision and the latter nanosecond precision.

## Ping Pong

This exercise helped me understand the basic usage of pipes.

> An easy way to remember that the input end comes first is that file descriptor 0 is standard input, and file descriptor 1 is standard output.
>
> https://www.gnu.org/software/libc/manual/html_node/Creating-a-Pipe.html

The file descriptors generated by pipes follow the same rules as the default file descriptors provided by bash to each process it starts. In other words, the first file descriptor returned by a pipe is the input end, and the second is the output end. The default file descriptors for a process are 0, 1, and 2, representing standard input, standard output, and standard error output, respectively.

To ensure proper process scheduling, the parent process needs to `sleep()` after writing data to allow the child process to execute first. Otherwise, the parent process might read the data meant for the child process. Besides using `sleep()`, the parent process could theoretically use other IPC synchronization mechanisms. This is necessary in systems with lower scheduling frequencies.

> â€œIf no data is available, a read on a pipe waits for either data to be written or for all file descriptors referring to the write end to be closed;â€ ([Cox et al., p. 16](zotero://select/library/items/TQKQI6M7)) ([pdf](zotero://open-pdf/library/items/Z9G8AERX?page=16&annotation=W26LA72A))

Regarding how to close a pipe, the pipe system call provides a convenient IPC mechanism: the sender closes the write end, the receiver reads until EOF, then the receiver closes the read end, completing the exit. This operation requires the receiver to close the write end beforehand, ensuring that only the sending process has a reference to the sending end before it closes the write end. Otherwise, the receiver will block on the `read` operation. Itâ€™s a good habit to close unnecessary file descriptors.

Additionally, we need to note that after `fork()`, the child process copies the parent process's file descriptor table and shares the file offset. Do not attempt to write data to the pipe from the child process, as this will cause data confusion:

> â€œAlthough fork copies the file descriptor table, each underlying file offset is shared between parent and child. Consider this example:â€ ([Cox et al., p. 15](zotero://select/library/items/TQKQI6M7)) ([pdf](zotero://open-pdf/library/items/Z9G8AERX?page=15&annotation=F8NLHFIJ))

## Primes

This exercise can be seen as a supplement and advancement of the pipe exercise. In this exercise, the main process writes objects to be filtered into the pipe one by one, and the child process sieves out composite numbers, retaining primes in the child process context. This allows for determining if incoming numbers are prime. Child processes are created only when necessary, maximizing resource efficiency.

This exercise requires using recursive functions, and I learned how to let the compiler skip the recursive dead loop check. This technique involves adding `__attribute__((noreturn))` to the function declaration. The experimental environment has strict compilation checks, and compilation fails without this annotation:

```bash
 ~/Doc/xv6-labs-2023 î‚± on main !2  make qemu          âœ” î‚³ base îœ¼ î‚³ at 15:09:11 
riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2 -DSOL_UTIL -DLAB_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o user/primes.o user/primes.c
user/primes.c: In function 'child_routine':
user/primes.c:6:5: error: infinite recursion detected [-Werror=infinite-recursion]
    6 | int child_routine(const int left_read_pipe, const int left_write_pipe)
      |     ^~~~~~~~~~~~~
user/primes.c:47:17: note: recursive call
   47 |                 child_routine(right_pipes[0], right_pipes[1]);
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cc1: all warnings being treated as errors
make: *** [user/primes.o] Error 1
```

Pipes are superior to files for two reasons:

1. Pipes are in-memory buffers, theoretically faster.
2. Pipes have no size limit, whereas files do.
3. Pipes handle garbage collection automatically, while files often need manual deletion (except for those in `/tmp`).
4. Pipes allow producers and consumers to process data in parallel, which files do not.

## Find

This exercise involves implementing the `find` command, a file system exercise. The `find` command searches for files in the file system. This exercise covers basic file system operations, such as reading directories, reading files, and comparing file names.

What exactly is a directory? According to the developer documentation:

> In an ext4 filesystem, a directory is more or less a flat file that maps an arbitrary byte string (usually ASCII) to an inode number on the filesystem.
>
> https://www.kernel.org/doc/html/latest/filesystems/ext4/directory.html

Through this experiment, I understood the Unix system's `dirent` structure and file name comparison. The `dirent` structure represents a directory entry, containing the file name, file type, file inode, etc. It stands for **Directory Entry**. File name comparison is done using the `strcmp()` function, a standard C library function for comparing two strings.

The `find` command skips files with an inode value of 0 because these are unused directory entries and do not need to be displayed. I also learned about the new C memory manipulation function `memmove()`, similar to `strcpy()`.

The `struct dirent` in real systems is much more complex than in xv6 because real systems need to support more functions, such as file permissions, file size, file creation time, etc. Real file directories are not necessarily stored linearly and may be tree-structured or mixed with hash tables and hash calculations to improve search efficiency. For instance, ext3 uses an **htree** hash tree as the data structure for file directories. According to the Linux developer documentation:

> A linear array of directory entries isnâ€™t great for performance, so a new feature was added to ext3 to provide a faster (but peculiar) balanced tree keyed off a hash of the directory entry name.
>
> https://www.kernel.org/doc/html/latest/filesystems/ext4/directory.html

## Xargs

This is an exercise requiring meticulous pointer manipulation. The goal is to implement the `xargs` command, which passes standard input content as arguments to another command. This involves pipes, file descriptor operations, process creation, etc.

The approach is to split the input string from standard input and assemble it with new arguments passed through `argv`, then forward it to the child process using `exec()`. Therefore, before forwarding, we need to allocate a sufficiently large space to store the possible arguments and commands.

How large should this space be? The experiment author did not specify clearly (the author's description of `MAXARG` is ambiguous). In theory, xv6 Bash has limits on the length and number of arguments. I found from documentation:

> And as an additional limit since 2.6.23, one argument must not be longer than MAX_ARG_STRLEN (131072).
>
> https://www.in-ulm.de/~mascheck/various/argmax/#maximum_number

Different systems have varying limits on the length and number of arguments. I eventually used `char __argv[100][MAXARG]` for argument storage, allowing for 100 arguments, each up to `MAXARG` bytes long.

## Debugging

While working on the `xargs` experiment, I encountered issues with the `exec()` function failing. Using `printf()` for kernel debugging was challenging due to the need to modify the `exec()` implementation. I attempted to attach gdb for further debugging.

Kernel debugging is interesting because the kernel runs in a virtual environment or directly on hardware, meaning gdb cannot directly attach to the kernel process. Thus, remote debugging through gdbâ€™s stub is required. The following explanation clarifies the basics of kernel debugging:

> Remote debugging is a very important technique for kernel development in general: the basic idea is that the main debugger (GDB in this case) runs separately from the program being debugged (the xv6 kernel atop QEMU) - they could be on completely separate machines, in fact.
>
> https://web.archive.org/web/20190308091152/http://zoo.cs.yale.edu:80/classes/cs422/2011/lec/l2-hw

## Why are `fork()` and `exec()` separate?

Although `fork()` and `exec()` are often used together, they are two different system calls. The main reason is to facilitate I/O redirection in the parent process. Additionally, `fork()` uses copy-on-write technology to avoid unnecessary memory copying.

## ç®€ä»‹

xv6æ˜¯mit s6.081æ“ä½œç³»ç»Ÿè¯¾ç¨‹ä½¿ç”¨çš„æ•™å­¦æ“ä½œç³»ç»Ÿï¼Œæ˜¯ä¸€ä¸ªç®€åŒ–çš„ï¼Œåªèƒ½åœ¨x86ä¸Šè¿è¡Œçš„æ“ä½œç³»ç»Ÿã€‚æœ¬åšå®¢æ—¨åœ¨è®°å½•å®ŒæˆLab1çš„è¿‡ç¨‹ä»¥åŠä¸€äº›å…³é”®çŸ¥è¯†ç‚¹ã€‚

## Sleep

ç¬¬ä¸€ä¸ªä»»åŠ¡æ˜¯å®ç°xv6çš„`sleep`æŒ‡ä»¤ã€‚è¿™ä¸æ˜¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œè€Œæ˜¯xv6çš„bashæŒ‡ä»¤ã€‚å®ç°æ–¹å¼æ˜¯è°ƒç”¨`sleep()`ç³»ç»Ÿè°ƒç”¨ã€‚

æœ¬ä»»åŠ¡ç›¸å¯¹ç®€å•ï¼Œå€¼å¾—ç©å‘³çš„æ˜¯è¯¥ä»»åŠ¡æ­ç¤ºäº†xv6çš„ç³»ç»Ÿè°ƒç”¨è°ƒç”¨è¿‡ç¨‹ï¼šå¤´æ–‡ä»¶æš´éœ²ç³»ç»Ÿè°ƒç”¨`sleep()`çš„æ¥å£ã€‚æŸ¥çœ‹`sysproc.c`æ–‡ä»¶ä¸­çš„`sys_sleep()`å‡½æ•°ï¼Œå¯ä»¥çœ‹åˆ°ç³»ç»Ÿè°ƒç”¨çš„å…·ä½“å®ç°ã€‚è€Œè¿æ¥ç”¨æˆ·æ€å‡½æ•°å’Œå†…æ ¸å‡½æ•°çš„æ˜¯ä¸€æ®µ**RISC-V**æ±‡ç¼–ï¼š

```assembly
.global sleep
sleep:
 li a7, SYS_sleep
 ecall
 ret
```

è¿™æ®µæ±‡ç¼–ä»£ç çš„ä½œç”¨æ˜¯å°†ç³»ç»Ÿè°ƒç”¨å·`SYS_sleep`æ”¾å…¥å¯„å­˜å™¨`a7`ï¼Œç„¶åè°ƒç”¨`ecall`æŒ‡ä»¤ï¼Œè§¦å‘ç³»ç»Ÿè°ƒç”¨ã€‚

`sleep()`ç³»ç»Ÿè°ƒç”¨è¿˜æ¶‰åŠ**ticks**è¿™ä¸€æ¦‚å¿µã€‚ticksåœ¨OSä¸­æ˜¯ä¸€ä¸ªç»•ä¸å¼€çš„è¯é¢˜ï¼Œåœ¨xv6ä¸­ä»£è¡¨ä¸¤æ¬¡æ—¶é’Ÿä¸­æ–­ä¹‹é—´çš„é—´éš”ã€‚åœ¨Linuxä¸­ï¼Œticksä¼šè¢«è®¾ç½®ä¸ºä¸€ä¸ªå®å®šä¹‰ï¼Œå¾€å¾€é»˜è®¤å€¼ä¸º100ï¼Œè¿™æ„å‘³ç€æ—¶é’Ÿæ¯ç§’é’Ÿæ»´ç­”100ä¸‹ï¼Œå¯ä»¥ç†è§£ä¸ºç‰©ç†é‡Œçš„é¢‘ç‡ã€‚åœ¨åšåŸºå‡†æµ‹è¯•æ—¶ï¼Œå½“ç¨‹åºå‘˜ä½¿ç”¨è¯¸å¦‚`times()`è¿™æ ·çš„å‡½æ•°æ—¶ï¼Œä¼šè¿”å›ä»¥ticksä¸ºå•ä½çš„æ—¶é—´ã€‚å½“ticksè¢«è°ƒé«˜æ—¶ï¼Œæ—¶é’Ÿç²¾åº¦å¢åŠ ï¼Œä½†è§‚æµ‹å¼€é”€ä¹Ÿéšä¹‹æ°´æ¶¨èˆ¹é«˜ã€‚æ‰€ä»¥ç¨‹åºå‘˜éœ€è¦ä¸ºè‡ªå·±çš„åº”ç”¨ç¨‹åºé€‰æ‹©åˆé€‚çš„tickså€¼ï¼Œè¿™ä¸€èˆ¬è¢«ç§°ä¸º**Software Clock**ã€‚å¦‚æœéœ€è¦è¿›è¡Œé«˜ç²¾åº¦è§‚æµ‹ï¼Œåœ¨Windowsä¸‹å¾€å¾€ä¼šä½¿ç”¨QPCï¼ˆQueryPerformanceCounterï¼‰å‡½æ•°ï¼Œè€Œåœ¨Linuxä¸‹ä¼šä½¿ç”¨`clock_gettime()`å‡½æ•°ï¼Œå‰è€…æä¾›å¾®ç§’çº§åˆ«çš„ç²¾åº¦ï¼Œåè€…èƒ½æä¾›çº³ç§’çº§åˆ«ç²¾åº¦ã€‚

## Ping Pong

è¿™ä¸ªç»ƒä¹ å¸®åŠ©æˆ‘ç†è§£äº†ç®¡é“çš„åŸºæœ¬ç”¨æ³•ã€‚

> An easy way to remember that the input end comes first is that file descriptor 0 is standard input, and file descriptor 1 is standard output.
>
> https://www.gnu.org/software/libc/manual/html_node/Creating-a-Pipe.html

ç®¡é“äº§ç”Ÿçš„æ–‡ä»¶æè¿°ç¬¦å’Œæ¯ä¸ªç”±bashå¯åŠ¨çš„è¿›ç¨‹è‡ªå¸¦çš„é»˜è®¤æ–‡ä»¶æè¿°ç¬¦çš„è§„åˆ™ä¿æŒäº†ä¸€è‡´æ€§ã€‚æ¢å¥è¯è¯´ï¼Œç®¡é“è¿”å›çš„ç¬¬ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦æ˜¯è¾“å…¥ç«¯ï¼Œç¬¬äºŒä¸ªæ–‡ä»¶æè¿°ç¬¦æ˜¯è¾“å‡ºç«¯ã€‚è¿›ç¨‹çš„é»˜è®¤æ–‡ä»¶æè¿°ç¬¦æ˜¯0ï¼Œ1ï¼Œ2ï¼Œåˆ†åˆ«ä»£è¡¨æ ‡å‡†è¾“å…¥ï¼Œæ ‡å‡†è¾“å‡ºï¼Œæ ‡å‡†é”™è¯¯è¾“å‡ºã€‚

ä¸ºäº†ä¿è¯è¿›ç¨‹è°ƒåº¦çš„æ­£ç¡®æ€§ï¼Œçˆ¶è¿›ç¨‹åœ¨å†™å…¥æ•°æ®åéœ€è¦`sleep()`ï¼Œè®©å­è¿›ç¨‹å…ˆæ‰§è¡Œã€‚å¦åˆ™ä¼šå°†æœ¬åº”è¯¥ç”±å­è¿›ç¨‹è¯»çš„æ•°æ®è¯»èµ°ã€‚çˆ¶è¿›ç¨‹é™¤äº†ç”¨`sleep()`ï¼Œç†è®ºä¸Šè¿˜å¯ä»¥ç”¨å…¶ä»–çš„IPCåŒæ­¥æœºåˆ¶ã€‚åœ¨è°ƒåº¦é¢‘ç‡è¾ƒä½çš„ç³»ç»Ÿä¸­ï¼Œè¿™ä¹ˆåšæ˜¯å¿…è¦çš„ã€‚

> â€œIf no data is available, a read on a pipe waits for either data to be written or for all file descriptors referring to the write end to be closed;â€ ([Cox ç­‰, p. 16](zotero://select/library/items/TQKQI6M7)) ([pdf](zotero://open-pdf/library/items/Z9G8AERX?page=16&annotation=W26LA72A))

å…³äºå¦‚ä½•å…³é—­ç®¡é“ï¼Œç®¡é“ç³»ç»Ÿè°ƒç”¨æä¾›äº†ä¸€ä¸ªä¾¿æ·çš„IPCæœºåˆ¶ï¼Œå³å‘é€æ–¹å…³é—­å†™ç«¯ï¼Œæ¥æ”¶æ–¹è¯»åˆ°EOFï¼Œç„¶åæ¥æ”¶æ–¹å…³é—­è¯»ç«¯ï¼Œè¿™æ ·å°±å®Œæˆäº†é€€å‡ºã€‚è¿™ä¸€æ“ä½œæœ‰ä¸€ä¸ªå‰ææ¡ä»¶ï¼Œå°±æ˜¯æ¥æ”¶æ–¹éœ€è¦æå‰å…³é—­å†™ç«¯ï¼Œè¿™æ ·åœ¨å‘é€æ–¹å…³é—­å†™ç«¯ä¹‹å‰ï¼Œåªæœ‰å‘é€è¿›ç¨‹å¯¹å‘é€ç«¯æœ‰å¼•ç”¨ï¼Œå¦åˆ™ä¼šé€ æˆæ¥æ”¶æ–¹é˜»å¡åœ¨`read`æ“ä½œä¸Šã€‚å…»æˆå…³é—­ä¸éœ€è¦çš„æ–‡ä»¶æè¿°ç¬¦æ˜¯ä¸€ä¸ªå¥½ä¹ æƒ¯ã€‚

æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜éœ€æ³¨æ„ï¼Œ`fork()`å®Œåï¼Œå­è¿›ç¨‹å°†æ‹·è´çˆ¶è¿›ç¨‹çš„æ–‡ä»¶æè¿°ç¬¦è¡¨ï¼Œä¸”å…±äº«æ–‡ä»¶åç§»é‡ã€‚ä¸è¦è¯•å›¾ä»å­è¿›ç¨‹ä¸­å¾€ç®¡é“ä¸­å†™æ•°æ®ï¼Œè¿™æ ·ä¼šé€ æˆæ•°æ®æ··ä¹±ï¼š

> â€œAlthough fork copies the file descriptor table, each underlying file offset is shared between parent and child. Consider this example:â€ ([Cox ç­‰, p. 15](zotero://select/library/items/TQKQI6M7)) ([pdf](zotero://open-pdf/library/items/Z9G8AERX?page=15&annotation=F8NLHFIJ))

## Primes

æœ¬ç»ƒä¹ å¯ä»¥çœ‹åšæ˜¯ç®¡é“ç»ƒä¹ çš„è¡¥å……å’Œè¿›é˜¶ã€‚åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œä¸»è¿›ç¨‹å°†éœ€è¦ç­›é€‰çš„å¯¹è±¡é€ä¸ªå†™å…¥ç®¡é“ï¼Œå­è¿›ç¨‹é€ä¸ªç­›å»åˆæ•°ï¼Œå°†è´¨æ•°ä¿å­˜åœ¨å­è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œè¿™æ ·åœ¨ä¸‹ä¸€ä¸ªæ•°åˆ°æ¥çš„æ—¶å€™ï¼Œå¯ä»¥è¿›è¡Œåˆ¤æ–­å…¶æ˜¯å¦ä¸ºè´¨æ•°ã€‚å­è¿›ç¨‹åªåœ¨å¿…è¦çš„æ—¶å€™åˆ›å»ºï¼Œè¿™æ ·ä¾¿å¯ä»¥å°½æœ€å¤§å¯èƒ½èŠ‚çº¦ç³»ç»Ÿèµ„æºã€‚

æœ¬ç»ƒä¹ éœ€è¦ä½¿ç”¨é€’å½’å‡½æ•°ï¼Œæˆ‘å­¦åˆ°äº†å¦‚ä½•è®©ç¼–è¯‘å™¨è·³è¿‡å‡½æ•°çš„é€’å½’æ­»å¾ªç¯æ£€æŸ¥ã€‚è¿™ä¸ªæŠ€å·§æ˜¯åœ¨å‡½æ•°å£°æ˜çš„æ—¶å€™åŠ ä¸Š`__attribute__((noreturn))`ã€‚å®éªŒç¯å¢ƒè®¾ç½®äº†ä¸¥æ ¼çš„ç¼–è¯‘æ£€æŸ¥ï¼Œå¦‚æœä¸åŠ è¿™ä¸ªæ³¨é‡Šï¼Œç¼–è¯‘æ— æ³•é€šè¿‡ï¼š

```bash
 ~/Doc/xv6-labs-2023 î‚± on main !2  make qemu          âœ” î‚³ base îœ¼ î‚³ at 15:09:11 
riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2 -DSOL_UTIL -DLAB_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o user/primes.o user/primes.c
user/primes.c: In function 'child_routine':
user/primes.c:6:5: error: infinite recursion detected [-Werror=infinite-recursion]
    6 | int child_routine(const int left_read_pipe, const int left_write_pipe)
      |     ^~~~~~~~~~~~~
user/primes.c:47:17: note: recursive call
   47 |                 child_routine(right_pipes[0], right_pipes[1]);
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cc1: all warnings being treated as errors
make: *** [user/primes.o] Error 1
```

ç®¡é“ä¼˜äºæ–‡ä»¶ï¼Œå…¶åŸå› æœ‰äºŒï¼š

1. ç®¡é“æ˜¯å†…å­˜ä¸­çš„ç¼“å†²åŒºï¼Œç†è®ºä¸Šé€Ÿåº¦æ›´å¿«ã€‚
2. ç®¡é“æ²¡æœ‰å¤§å°ä¸Šé™ï¼Œæ–‡ä»¶æœ‰å¤§å°ä¸Šé™ã€‚
3. ç®¡é“è‡ªåŠ¨è¿›è¡Œåƒåœ¾å›æ”¶ï¼Œæ–‡ä»¶å¾€å¾€éœ€è¦æ‰‹åŠ¨åˆ é™¤ï¼ˆæ”¾åœ¨`/tmp`ä¸‹é™¤å¤–ï¼‰
4. ç®¡é“å…è®¸ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…å¹¶è¡Œå¤„ç†æ•°æ®ï¼Œæ–‡ä»¶ä¸å…è®¸ã€‚

## Find

è¿™ä¸ªç»ƒä¹ æ˜¯ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿç»ƒä¹ ï¼Œéœ€è¦å®ç°`find`æŒ‡ä»¤ã€‚`find`æŒ‡ä»¤çš„åŠŸèƒ½æ˜¯åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­æŸ¥æ‰¾æ–‡ä»¶ã€‚è¿™ä¸ªç»ƒä¹ æ¶‰åŠåˆ°äº†æ–‡ä»¶ç³»ç»Ÿçš„åŸºæœ¬æ“ä½œï¼Œå¦‚è¯»å–ç›®å½•ï¼Œè¯»å–æ–‡ä»¶ï¼Œæ–‡ä»¶åæ¯”è¾ƒç­‰ã€‚

<!-- ![Parse string](image.png) -->

ç©¶ç«Ÿä»€ä¹ˆæ˜¯ç›®å½•ï¼Ÿå¼•ç”¨å¼€å‘è€…æ–‡æ¡£çš„è§£é‡Šï¼š

> In an ext4 filesystem, a directory is more or less a flat file that maps an arbitrary byte string (usually ASCII) to an inode number on the filesystem.
>
> https://www.kernel.org/doc/html/latest/filesystems/ext4/directory.html

é€šè¿‡è¿™ä¸ªå®éªŒï¼Œæˆ‘ç†è§£äº†Unixç³»ç»Ÿçš„`dirent`ç»“æ„ä½“ï¼Œä»¥åŠæ–‡ä»¶åçš„æ¯”è¾ƒã€‚`dirent`ç»“æ„ä½“æ˜¯ä¸€ä¸ªç›®å½•é¡¹ï¼ŒåŒ…å«äº†æ–‡ä»¶åï¼Œæ–‡ä»¶ç±»å‹ï¼Œæ–‡ä»¶inodeç­‰ä¿¡æ¯ã€‚æ˜¯**Directory Entry**çš„ç¼©å†™ã€‚è€Œæ–‡ä»¶åçš„æ¯”è¾ƒæ˜¯é€šè¿‡`strcmp()`å‡½æ•°å®ç°çš„ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯Cè¯­è¨€çš„æ ‡å‡†åº“å‡½æ•°ï¼Œç”¨äºæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ã€‚

å¯¹äºinodeå€¼ä¸º0çš„æ–‡ä»¶ï¼Œ`find`æŒ‡ä»¤ä¼šè·³è¿‡ã€‚è¿™æ˜¯å› ä¸ºinodeä¸º0çš„æ–‡ä»¶æ˜¯æœªä½¿ç”¨çš„ç›®å½•é¡¹ï¼Œä¸éœ€è¦æ˜¾ç¤ºã€‚æˆ‘è¿˜å­¦åˆ°äº†æ–°çš„Cè¯­è¨€å†…å­˜æ“ä½œå‡½æ•°`memmove()`ï¼Œè¿™ä¸ªå‡½æ•°ç±»ä¼¼äº`strcpy()`ã€‚

çœŸå®ç³»ç»Ÿçš„`struct dirent`ç»“æ„ä½“æ¯”xv6ä¸­çš„è¦å¤æ‚å¾—å¤šï¼Œå› ä¸ºçœŸå®ç³»ç»Ÿä¸­çš„æ–‡ä»¶ç³»ç»Ÿè¦æ”¯æŒæ›´å¤šçš„åŠŸèƒ½ï¼Œæ¯”å¦‚æ–‡ä»¶æƒé™ï¼Œæ–‡ä»¶å¤§å°ï¼Œæ–‡ä»¶åˆ›å»ºæ—¶é—´ç­‰ã€‚å®é™…çš„æ–‡ä»¶ç›®å½•ä¸ä¸€å®šæ˜¯çº¿æ€§å­˜å‚¨çš„ï¼Œå¯èƒ½æ˜¯æ ‘çŠ¶ç»“æ„ï¼Œç”šè‡³æºæ‚äº†å“ˆå¸Œè¡¨ä»¥åŠå“ˆå¸Œè®¡ç®—ä»¥æé«˜æŸ¥æ‰¾æ•ˆç‡ï¼Œæ¯”å¦‚ext3ä¸­å°±å¼•å…¥äº†**htree**å“ˆå¸Œæ ‘ä½œä¸ºè¡¨ç¤ºæ–‡ä»¶ç›®å½•çš„æ•°æ®ç»“æ„ã€‚å‚è€ƒLinuxå¼€å‘è€…æ–‡æ¡£ï¼š

> A linear array of directory entries isnâ€™t great for performance, so a new feature was added to ext3 to provide a faster (but peculiar) balanced tree keyed off a hash of the directory entry name.
>
> https://www.kernel.org/doc/html/latest/filesystems/ext4/directory.html

## Xargs

ä¸å¾—ä¸è¯´è¿™æ˜¯ä¸€ä¸ªéœ€è¦ç»†è…»æŒ‡é’ˆæ“ä½œçš„ç»ƒä¹ ã€‚ã€‚ã€‚è¿™ä¸ªç»ƒä¹ çš„ç›®çš„æ˜¯å®ç°`xargs`æŒ‡ä»¤ï¼Œè¿™ä¸ªæŒ‡ä»¤çš„åŠŸèƒ½æ˜¯å°†æ ‡å‡†è¾“å…¥çš„å†…å®¹ä½œä¸ºå‚æ•°ä¼ é€’ç»™å¦ä¸€ä¸ªæŒ‡ä»¤ã€‚è¿™ä¸ªç»ƒä¹ æ¶‰åŠåˆ°äº†ç®¡é“ï¼Œæ–‡ä»¶æè¿°ç¬¦çš„æ“ä½œï¼Œè¿›ç¨‹çš„åˆ›å»ºç­‰ã€‚

æœ¬å®éªŒçš„æ€è·¯æ˜¯å¯¹ä»æ ‡å‡†è¾“å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œåˆ†å‰²åå’Œ`argv`ä¼ å…¥çš„æ–°å‚æ•°è¿›è¡Œç»„è£…ï¼Œç„¶åç”¨`exec()`è½¬å‘ç»™å­è¿›ç¨‹æ‰§è¡Œã€‚æ‰€ä»¥åœ¨è½¬å‘å‰ï¼Œæˆ‘ä»¬éœ€è¦å¼€è¾Ÿä¸€å—è¶³å¤Ÿå¤§çš„ç©ºé—´å­˜æ”¾å¯èƒ½çš„å‚æ•°å’ŒæŒ‡ä»¤ã€‚

è¿™å—å†…å­˜éœ€è¦å¼€è¾Ÿå¤šå¤§ï¼Ÿå®éªŒçš„ä½œè€…å¹¶æ²¡æœ‰æ˜ç¡®è§„å®šï¼ˆå®éªŒä½œè€…å¯¹`MAXARG`çš„æè¿°å……æ»¡æ­§ä¹‰ã€‚ã€‚ã€‚ï¼‰ï¼Œç†è®ºä¸Šxv6 Bashçš„å‚æ•°é•¿åº¦å’Œå‚æ•°ä¸ªæ•°æ˜¯æœ‰ä¸Šé™çš„ã€‚æˆ‘æŸ¥é˜…æ–‡æ¡£å‘ç°ï¼š

> And as additional limit since 2.6.23, one argument must not be longer than MAX_ARG_STRLEN (131072).
> 
> https://www.in-ulm.de/~mascheck/various/argmax/#maximum_number

ä¸åŒç³»ç»Ÿå¯¹äºå‚æ•°çš„é•¿åº¦å’Œä¸ªæ•°éƒ½æœ‰ä¸åŒçš„é™åˆ¶ã€‚æˆ‘æœ€åä½¿ç”¨`char __argv[100][MAXARG];`ä½œä¸ºå‚æ•°çš„å­˜å‚¨ç©ºé—´ï¼Œè¿™æ ·å¯ä»¥å­˜å‚¨100ä¸ªå‚æ•°ï¼Œæ¯ä¸ªå‚æ•°çš„é•¿åº¦ä¸º`MAXARG`å­—èŠ‚ã€‚

## å…³äºè°ƒè¯•

æˆ‘åœ¨åš`xargs`å®éªŒçš„æ—¶å€™ï¼Œé‡åˆ°äº†`exec()`å‡½æ•°æ‰§è¡Œå¤±è´¥çš„é—®é¢˜ã€‚å•çº¯ä½¿ç”¨`printf()`å¯¹å†…æ ¸è¿›è¡Œè°ƒè¯•è®©æˆ‘åƒå°½äº†è‹¦å¤´ï¼Œå› ä¸ºä¿®æ”¹`exec()`å‡½æ•°çš„å®ç°ã€‚æˆ‘å°è¯•attach gdbè¿›è¡Œè¿›ä¸€æ­¥è°ƒè¯•ã€‚

è°ƒè¯•å†…æ ¸æ˜¯æœ‰è¶£çš„ï¼Œå› ä¸ºå†…æ ¸éœ€è¦è¿è¡Œåœ¨ä¸€ä¸ªè™šæ‹Ÿç¯å¢ƒä¸­ï¼Œç”šè‡³ç›´æ¥è¿è¡Œåœ¨ç¡¬ä»¶ä¹‹ä¸Šï¼Œè¿™æ„å‘³ç€gdbæ— æ³•ç›´æ¥attachåˆ°å†…æ ¸è¿›ç¨‹ä¸Šã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä½¿ç”¨gdbçš„è¿œç¨‹è°ƒè¯•åŠŸèƒ½ï¼Œé€šè¿‡gdbçš„stubæ¥è°ƒè¯•å†…æ ¸ã€‚ä¸‹é¢è¿™æ®µè¯é˜è¿°äº†å†…æ ¸è°ƒè¯•çš„åŸºæœ¬åŸç†ï¼š

> Remote debugging is a very important technique for kernel development in general: the basic idea is that the main debugger (GDB in this case) runs separately from the program being debugged (the xv6 kernel atop QEMU) - they could be on completely separate machines, in fact.
>
> https://web.archive.org/web/20190308091152/http://zoo.cs.yale.edu:80/classes/cs422/2011/lec/l2-hw

## ä¸ºä»€ä¹ˆ`fork()`å’Œ`exec()`æ˜¯åˆ†å¼€çš„ï¼Ÿ

è™½ç„¶`fork()`å’Œ`exec()`å¾€å¾€ä¸€èµ·ä½¿ç”¨ï¼Œä½†æ˜¯å®ƒä»¬æ˜¯ä¸¤ä¸ªä¸åŒçš„ç³»ç»Ÿè°ƒç”¨ã€‚ä¸»è¦åŸå› æ˜¯æ–¹ä¾¿åœ¨çˆ¶è¿›ç¨‹ä¸­å®ŒæˆI/Oé‡å®šå‘ã€‚æ­¤å¤–ï¼Œ`fork()`ä½¿ç”¨äº†copy-on-writeæŠ€æœ¯ï¼Œé¿å…äº†æ— æ•ˆçš„å†…å­˜æ‹·è´ã€‚
