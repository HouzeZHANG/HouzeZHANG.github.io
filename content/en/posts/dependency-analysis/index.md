---
title: "Dependency Analysis for Windows C++ Project"
date: 2024-05-05T15:25:57+02:00
draft: false
---

ä¸­æ–‡åœ¨ä¸‹é¢ğŸ‘‡

## Introduction

When deconstructing and porting complex C++ projects, managing and analyzing project file dependencies is crucial. Online game development involves a myriad of dependencies and library files: from engines to UI; from clients to rendering and media libraries to servers. Clarifying the dependency relationships within a project is a prerequisite for porting and refactoring. Trying to port or refactor without understanding these dependencies is like a blind person feeling an elephant â€” you don't know where to start.

This article will introduce my experience in analyzing dependencies of large C++ projects on the Windows platform.

## Visual Studio's Project and Solution

*Projects* and *Solutions* are logical descriptions of C++ modules in Visual Studio (referred to as VS hereafter), where a Solution is a collection of Projects. Generally, without using CMake templates, compilation and linking are done at the Project level, producing either C++ executable files or C++ libraries (static or dynamic). Projects can depend on each other since the output objects can have dependencies; for example, an executable generated by Project A may depend on a static or dynamic library generated by Project B during compilation or runtime, or it may depend on an import library.

Usually, configuring a C++ project is done at the Project level. By right-clicking on a Project entry, developers can easily use the VS GUI to set build options for the Project. These parameters are persistently stored locally in configuration files. Compiler options, include file paths, linker search paths, target settings, etc., are key points to consider. It's generally recommended to configure projects via the GUI rather than directly modifying the XML configuration files, which can be thousands of lines long. By the way, if you have installed LLVM-related development tools via the VS installer, you can find the clang-cl compiler in the configuration options, which uses Clang as the frontend and Windows MSVC platform as the backend compiler.

## Classification of Library Files and Import Libraries

Before diving into dependency analysis, we need to understand how dependencies are manifested. Typically, in a C++ program, dependencies are exhibited in executable programs relying on libraries and libraries depending on other libraries. In Windows, static libraries end with `.lib`, while dynamic libraries end with `.dll`. Often, you'll see files with the same name but different extensions (e.g., `.lib` and `.dll`) in a project; this is likely due to the import library mechanism on Windows. Simply put, during compilation, a program needs to link the import library corresponding to a dynamic library to use that dynamic library with the dynamic linker during execution. This is somewhat similar to how C++ compilation and linking phases require including library header files to obtain symbols from the library, allowing the compiler linker to generate executable files successfully.

## Dependency Analysis Methods

How do we analyze dependencies? If you want to analyze dynamic library dependencies or executable files, you can use tools like Dependency Walker or Dependencies. As of 2024, Dependency Walker supports detecting dependency errors (such as checking for circular dependencies), claims to be able to find all dependencies, supports persistence by saving dependency relationships in a text format locally (though readability can be challenging). On the other hand, Dependencies doesn't have the aforementioned features but is notably faster in parsing dependencies compared to Dependency Walker. One tricky aspect is that Windows' library file matching rules are case-insensitive, so you may need to manually adjust the case when organizing or writing reports.

As for static library dependency analysis, we can refer to the toolchain configuration files for insights. In theory, static libraries cannot be analyzed externally by third-party software. This provides a natural security advantage for static libraries compared to dynamic libraries (of course, with clear disadvantages such as static size, memory usage during execution, incremental compilation speed, etc.). In the gaming industry, it's quite common to distribute static libraries since developers prefer not to expose too much of their code implementation to hackers.

## Runtime

During dependency analysis, you often encounter library names containing "RT," which stands for *runtime*. Runtime generally refers to the environment required for a program to run. The kernel is also part of the runtime.

## PlantUML

PlantUML is a software that helps programmers represent project dependencies. Its advantages include simplicity, extensibility, separate source code storage that can be merged, automatic formatting, among others.

## Conclusion

Dependency analysis is a prerequisite step for porting and refactoring C++ projects. On the Windows platform, we can use tools like the VS GUI, Dependency Walker, Dependencies, inspect toolchain configuration files, PlantUML, etc., to help us perform dependency analysis.

## Introduction

åœ¨è§£æ„ï¼Œç§»æ¤å¤æ‚C++å·¥ç¨‹æ—¶ï¼Œå¯¹é¡¹ç›®æ–‡ä»¶çš„ä¾èµ–ç®¡ç†ä¸åˆ†æè‡³å…³é‡è¦ã€‚åœ¨çº¿æ¸¸æˆå¼€å‘æ¶‰åŠåƒå¥‡ç™¾æ€ªçš„ä¾èµ–å’Œåº“æ–‡ä»¶ï¼šä¸‹åˆ°å¼•æ“ï¼Œä¸Šè‡³UIï¼›å‰æœ‰å®¢æˆ·ç«¯ï¼Œåæœ‰æ¸²æŸ“ä¸åª’ä½“åº“ä¸æœåŠ¡å™¨ã€‚ç†æ¸…é¡¹ç›®çš„ä¾èµ–å…³ç³»æ˜¯å¯¹é¡¹ç›®è¿›è¡Œç§»æ¤ï¼Œé‡æ„çš„å…ˆå†³æ­¥éª¤ã€‚æä¸æ¸…æ¥šä¾èµ–å…³ç³»å°±è¿›è¡Œç§»æ¤å’Œé‡æ„ï¼Œå¥½ä¼¼ç›²äººæ‘¸è±¡ï¼Œæ— ä»ä¸‹æ‰‹ã€‚

è¿™ç¯‡æ–‡ç« å°†ä»‹ç»æˆ‘åœ¨Windowså¹³å°ä¸Šåˆ†æå¤§å‹C++å·¥ç¨‹ä¾èµ–æ—¶çš„ç»éªŒã€‚

## Visual Studioçš„Projectä¸Solution

*Project*å’Œ*Solution*æ˜¯*Visual studio*ï¼ˆä»¥ä¸‹ç®€ç§°VSï¼‰å¯¹C++æ¨¡å—çš„é€»è¾‘æè¿°ï¼ŒSolutionæ˜¯Projectçš„é›†åˆã€‚ä¸€èˆ¬æ¥è¯´ï¼Œåœ¨ä¸ä½¿ç”¨CMakeæ¨¡æ¿çš„æƒ…å†µä¸‹ï¼Œç¼–è¯‘å’Œé“¾æ¥ä»¥Projectä¸ºå•ä½è¿›è¡Œï¼Œå…¶è¾“å‡ºå¯ä»¥ä¸ºC++å¯æ‰§è¡Œæ–‡ä»¶ï¼Œä¹Ÿå¯ä»¥æ˜¯C++çš„åº“ï¼šé™æ€åº“ï¼ŒåŠ¨æ€é“¾æ¥åº“ã€‚Projectä¹‹é—´å¯ä»¥äº’ç›¸ä¾èµ–ï¼Œå› ä¸ºè¾“å‡ºçš„å¯¹è±¡ä¹‹é—´å¯ä»¥å­˜åœ¨ä¾èµ–å…³ç³»ï¼šæ¯”å¦‚Aé¡¹ç›®ç”Ÿæˆçš„Aå¯æ‰§è¡Œæ–‡ä»¶åœ¨ç¼–è¯‘é˜¶æ®µï¼Œæˆ–è€…è¿è¡Œé˜¶æ®µå°†ä¾èµ–Bé¡¹ç›®ç”Ÿæˆçš„é™æ€åº“ï¼ŒåŠ¨æ€åº“ï¼Œäº¦æˆ–æ˜¯*import library*ã€‚

ä¸€èˆ¬æ¥è¯´ï¼Œå¯¹C++é¡¹ç›®çš„é…ç½®ä¹Ÿæ˜¯ä»¥Projectä¸ºæœ€å°å•ä½è¿›è¡Œçš„ã€‚å³å‡»Projectæ¡ç›®ï¼Œç¨‹åºå‘˜å¯ä»¥æ–¹ä¾¿åœ°ä»¥VSçš„GUIç•Œé¢å¯¹Projectçš„Buildé€‰é¡¹è¿›è¡Œè®¾ç½®ã€‚è¿™äº›å‚æ•°éƒ½ä¼šä»¥é…ç½®æ–‡ä»¶çš„å½¢å¼æŒä¹…åŒ–åœ°å­˜å‚¨åœ¨æœ¬åœ°ã€‚å…¶ä¸­ç¼–è¯‘å™¨é€‰é¡¹ï¼Œinclude file pathï¼Œlinkerçš„æœç´¢è·¯å¾„ï¼Œtargetè®¾ç½®ï¼Œéƒ½æ˜¯éœ€è¦å…³æ³¨çš„é‡ç‚¹ã€‚ä¸€èˆ¬è¿˜æ˜¯å»ºè®®é€šè¿‡GUIå¯¹å·¥ç¨‹é…ç½®è¿›è¡Œè®¾ç½®ï¼Œè€Œä¸æ˜¯ç›´æ¥æ‰“å¼€é…ç½®æ–‡ä»¶ä¿®æ”¹åŠ¨è¾„ä¸Šåƒè¡Œçš„XMLæ–‡ä»¶ã€‚é¡ºä¾¿æä¸€å¥ï¼Œå¦‚æœåœ¨VS installerä¸­å®‰è£…äº†LLVMç›¸å…³çš„å¼€å‘å·¥å…·ï¼Œä½ ä¾¿èƒ½åœ¨é…ç½®é€‰é¡¹ä¸­æ‰¾åˆ°clang-clè¿™ä¸ªä»¥Clangä¸ºå‰ç«¯ï¼ŒWindows MSVCå¹³å°ä¸ºç¼–è¯‘å™¨åç«¯çš„ç¼–è¯‘å™¨ã€‚

## åº“æ–‡ä»¶çš„åˆ†ç±»ä¸import library

åœ¨è¿›è¡Œä¾èµ–åˆ†æä¹‹å‰ï¼Œæˆ‘ä»¬è¦æ˜ç™½ä¾èµ–çš„è¡¨ç°å½¢å¼æ˜¯ä»€ä¹ˆã€‚ä¸€èˆ¬æ¥è¯´ï¼ŒC++ç¨‹åºçš„ä¾èµ–å…³ç³»è¡¨ç°åœ¨å¯æ‰§è¡Œç¨‹åºä¾èµ–åº“ä»¥åŠåº“å’Œåº“ä¹‹é—´äº’ç›¸ä¾èµ–ã€‚åœ¨Windowsä¸‹ï¼Œé™æ€åº“ä»¥`.lib`ç»“å°¾ï¼ŒåŠ¨æ€åº“ä»¥`.dll`ç»“å°¾ã€‚åœ¨å¾ˆå¤šæ—¶å€™ï¼Œä½ èƒ½çœ‹è§é¡¹ç›®ä¸­å­˜åœ¨åŒåçš„`.lib`å’Œ`.dll`æ–‡ä»¶ï¼Œè¿™å¤§æ¦‚ç‡æ˜¯å› ä¸ºWindowsä¸‹çš„import libraryæœºåˆ¶åœ¨ä½œç¥Ÿã€‚ç®€å•æ¥è¯´ç¨‹åºéœ€è¦åœ¨ç¼–è¯‘é˜¶æ®µå°†åŠ¨æ€åº“å¯¹åº”çš„å¯¼å…¥åº“é“¾æ¥ï¼Œæ‰å¯ä»¥é¡ºåˆ©åœ¨æ‰§è¡Œé˜¶æ®µç”¨åŠ¨æ€é“¾æ¥å™¨ä½¿ç”¨åŠ¨æ€åº“ã€‚è¿™æœ‰ä¸€ç‚¹ç±»ä¼¼C++ç¼–è¯‘é“¾æ¥é˜¶æ®µéœ€è¦includeåº“çš„å¤´æ–‡ä»¶ï¼Œä»è€Œè·å¾—åº“é‡Œçš„ç¬¦å·æ‰èƒ½è®©ç¼–è¯‘å™¨é“¾æ¥å™¨æˆåŠŸç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ã€‚

## ä¾èµ–åˆ†ææ–¹æ³•

å¦‚ä½•åˆ†æä¾èµ–ï¼Ÿå¦‚æœå¸Œæœ›è§£æåŠ¨æ€åº“ä¾èµ–æˆ–è€…å¯æ‰§è¡Œæ–‡ä»¶çš„è¯å¯ä»¥ä½¿ç”¨Dependency Walkeræˆ–è€…Dependenciesè¿™ä¸¤æ¬¾å·¥å…·ã€‚æˆªæ­¢2024å¹´ï¼Œå‰è€…æ”¯æŒä¾èµ–errorçš„æ£€æµ‹ï¼ˆæ¯”å¦‚æ£€æµ‹æ˜¯å¦å­˜åœ¨å¾ªç¯ä¾èµ–ï¼‰ï¼Œâ€œå·ç§°â€èƒ½æœåˆ°å…¨éƒ¨çš„ä¾èµ–ï¼Œæ”¯æŒæŒä¹…åŒ–ï¼Œèƒ½å°†ä¾èµ–å…³ç³»ä»¥æ–‡æœ¬æ ¼å¼ä¿å­˜åœ¨æœ¬åœ°ï¼ˆå¯è¯»æ€§å ªå¿§ï¼‰ã€‚åè€…æ²¡æœ‰ä¸Šè¿°åŠŸèƒ½ï¼Œä½†è§£æé€Ÿåº¦æ˜æ˜¾æ¯”å‰è€…å¿«ä¸å°‘ã€‚æ¯”è¾ƒæ£˜æ‰‹çš„æ˜¯Windowsä¸‹åº“æ–‡ä»¶çš„matchè§„åˆ™æ˜¯ä¸åŒºåˆ†å¤§å°å†™çš„ï¼Œåœ¨å†™æŠ¥å‘Šåšæ•´ç†çš„æ—¶å€™éœ€è¦æ‰‹å·¥æ”¹å¤§å°å†™ã€‚

è‡³äºé™æ€åº“çš„ä¾èµ–åˆ†æï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æŸ¥çœ‹å·¥å…·é“¾é…ç½®æ–‡ä»¶æ¥äº†è§£ã€‚é™æ€åº“ç†è®ºä¸Šæ˜¯æ— æ³•é€šè¿‡å¤–éƒ¨ç¬¬ä¸‰æ–¹è§£æè½¯ä»¶è¿›è¡Œè§£æçš„ã€‚è¿™è®©é™æ€åº“å’ŒåŠ¨æ€åº“æ¯”æœ‰å¤©ç„¶çš„å®‰å…¨ä¼˜åŠ¿ï¼ˆå½“ç„¶åŠ£åŠ¿ä¹Ÿå¾ˆæ˜æ˜¾ï¼Œé™æ€ä½“ç§¯ï¼Œæ‰§è¡Œæ—¶å†…å­˜å ç”¨ä½“ç§¯ï¼Œå¢é‡ç¼–è¯‘é€Ÿåº¦etcã€‚ã€‚ã€‚ï¼‰ã€‚åœ¨æ¸¸æˆäº§ä¸šä¸­ï¼Œé™æ€åº“å‘å¸ƒæ˜¯è›®å¸¸è§çš„ï¼Œæ¯•ç«Ÿå¼€å‘è€…ä¸å¸Œæœ›ä»£ç çš„å®ç°è¿‡å¤šåœ°æš´éœ²ç»™é»‘å®¢ã€‚

## Runtime

åœ¨è¿›è¡Œä¾èµ–åˆ†æçš„æ—¶å€™ï¼Œç»å¸¸èƒ½çœ‹è§åº“çš„åå­—ä¸­å«æœ‰*RT*ã€‚ä¸€èˆ¬è¿™æ˜¯*runtime*çš„ç®€ç§°ã€‚Runtimeä¸€èˆ¬æŒ‡ç¨‹åºè¿è¡Œæ—¶æ‰€éœ€è¦çš„ç¯å¢ƒã€‚Kernelä¹Ÿæ˜¯runtimeçš„ä¸€éƒ¨åˆ†ã€‚

## PlantUML

PlantUMLæ˜¯ä¸€æ¬¾å¸®åŠ©ç¨‹åºå‘˜è¡¨ç¤ºé¡¹ç›®ä¾èµ–çš„è½¯ä»¶ã€‚ç®€æ´ï¼Œå¯æ‰©å±•ï¼Œæºä»£ç å¯ä»¥åˆ†å¼€ä¿å­˜ï¼Œä¸€åŒmergeï¼Œè‡ªåŠ¨æ’ç‰ˆï¼Œè¿™äº›éƒ½æ˜¯ä»–çš„ä¼˜åŠ¿ã€‚

## Conclusion

ä¾èµ–åˆ†ææ˜¯C++å·¥ç¨‹ç§»æ¤ï¼Œé‡æ„çš„å…ˆå†³æ­¥éª¤ã€‚åœ¨Windowså¹³å°ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨VSçš„GUIç•Œé¢ï¼ŒDependency Walkerï¼ŒDependenciesï¼ŒæŸ¥çœ‹å·¥å…·é“¾é…ç½®æ–‡ä»¶ï¼ŒPlantUMLç­‰å·¥å…·æ¥å¸®åŠ©æˆ‘ä»¬å®Œæˆä¾èµ–åˆ†æã€‚
