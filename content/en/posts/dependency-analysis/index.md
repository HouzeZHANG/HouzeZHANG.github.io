---
title: "Dependency Analysis for Windows C++ Project"
date: 2024-05-05T15:25:57+02:00
draft: false
---

ä¸­æ–‡åœ¨ä¸‹é¢ğŸ‘‡

## Introduction

When deconstructing and porting complex C++ projects, managing and analyzing project file dependencies are crucial. Online game development involves a myriad of dependencies and library files: from engines to UI; from clients to rendering and media libraries, and network servers. Clarifying the dependency relationships within a project is a prerequisite step for porting and refactoring projects. Trying to undertake porting and refactoring without understanding the dependencies is like a blind person feeling an elephant without knowing where to start.

This article will introduce the methodology and experience I've gained in analyzing dependencies of large and complex C++ projects on the Windows platform.

## Visual Studio's Projects and Solutions

*Projects* and *Solutions* are logical descriptions of C++ modules in Visual Studio (hereinafter referred to as VS), where a Solution is a collection of Projects. Generally, without using CMake templates, compilation and linking are performed at the Project level, and the output can be a C++ executable or a library: static or dynamic. Projects can depend on each other because the objects generated by one Project may depend on objects generated by another Project during compilation or runtime, such as executable A depending on a static or dynamic library generated by Project B or an import library.

Usually, the configuration of C++ projects is done at the Project level. By right-clicking on a Project entry, programmers can easily set Build options for the Project using VS's GUI interface. These parameters are persistently stored locally in configuration files. Key areas of focus include compiler options, include file paths, linker search paths, target settings, etc. It's generally recommended to configure project settings through the GUI rather than directly modifying the XML file, which can be thousands of lines long. By the way, if you have installed LLVM-related development tools in the VS installer, you can find the clang-cl compiler in the configuration options. It uses Clang as the frontend and Windows MSVC platform as the backend compiler.

## Categorization of Library Files and Import Libraries

Before delving into dependency analysis, it's important to understand how dependencies are represented. Typically, in C++ programs, dependencies are manifested in executable programs depending on libraries, and libraries depending on other libraries. In Windows, static libraries end with `.lib`, while dynamic libraries end with `.dll`. Often, you may see files with the same name but different extensions (`.lib` and `.dll`) in a project, which is likely due to the import library mechanism in Windows. In simple terms, during compilation, a program needs to link with the import library corresponding to the dynamic library to be able to use it with the dynamic linker during execution. This is somewhat similar to how C++ compilation and linking require including library header files and symbols to allow the compiler linker to successfully generate executable files.

## Dependency Analysis Methods

How do we analyze dependencies? If you want to resolve dynamic library dependencies or analyze executable files, tools like Dependency Walker or Dependencies can be used. As of 2024, the former supports dependency error detection (such as detecting cyclic dependencies), claims to be able to find all dependencies, supports persistence, and can save dependency relationships in text format locally (though readability may be a concern). The latter does not have the aforementioned features but is noticeably faster in analysis compared to the former. A somewhat annoying aspect is that Windows' library file matching rules are case-insensitive, so manual case modification is required when writing reports or organizing information.

As for static library dependency analysis, the solution is to look at the toolchain configuration files. Static libraries theoretically cannot be analyzed by external third-party software. This distinguishes them from dynamic libraries, which have a natural security advantage (of course, with drawbacks such as static size, memory consumption during execution, incremental compilation speed, etc.). In the gaming industry, releasing static libraries is quite common because you don't want the code implementation to be exposed to hackers.

## Runtime

During dependency analysis, you may often encounter library names containing "RT," which is short for "runtime." Runtime generally refers to the environment needed for a program to run. In the context of C/C++, the runtime is usually small, and the libraries needed for a C++ program's execution are not many. As a comparison, languages like Golang require an additional runtime to assist in garbage collection operations. The kernel is also part of the runtime.

## PlantUML

PlantUML is a good software for representing dependencies. It's concise, extensible, separates source code, and has automatic layout features, which are its advantages.

## Conclusion

Dependency analysis is a prerequisite step for porting and refactoring C++ projects. On the Windows platform, we can use tools such as VS's GUI interface, Dependency Walker, Dependencies, examine toolchain configuration files, and PlantUML to help us perform dependency analysis.

## Introduction

åœ¨è§£æ„ï¼Œç§»æ¤å¤æ‚C++å·¥ç¨‹æ—¶ï¼Œå¯¹é¡¹ç›®æ–‡ä»¶çš„ä¾èµ–ç®¡ç†ä¸åˆ†æè‡³å…³é‡è¦ã€‚åœ¨çº¿æ¸¸æˆå¼€å‘æ¶‰åŠåƒå¥‡ç™¾æ€ªçš„ä¾èµ–å’Œåº“æ–‡ä»¶ï¼šä¸‹åˆ°å¼•æ“ï¼Œä¸Šè‡³UIï¼›å‰æœ‰å®¢æˆ·ç«¯ï¼Œåæœ‰æ¸²æŸ“ä¸åª’ä½“åº“ä¸ç½‘ç»œæœåŠ¡å™¨ã€‚ç†æ¸…é¡¹ç›®çš„ä¾èµ–å…³ç³»æ˜¯å¯¹é¡¹ç›®è¿›è¡Œç§»æ¤ï¼Œé‡æ„çš„å…ˆå†³æ­¥éª¤ã€‚æä¸æ¸…æ¥šä¾èµ–å…³ç³»å°±è¿›è¡Œç§»æ¤å’Œé‡æ„ï¼Œå¥½ä¼¼ç›²äººæ‘¸è±¡æ— ä»ä¸‹æ‰‹ã€‚

è¿™ç¯‡æ–‡ç« å°†ä»‹ç»æˆ‘åœ¨Windowså¹³å°ä¸Šåˆ†æå¤§å‹å¤æ‚C++å·¥ç¨‹çš„ä¾èµ–æ—¶çš„æ–¹æ³•è®ºä»¥åŠç»éªŒã€‚

## Visual Studioçš„Projectä¸Solution

*Project*å’Œ*Solution*æ˜¯*Visual studio*ï¼ˆä»¥ä¸‹ç®€ç§°VSï¼‰å¯¹C++æ¨¡å—çš„é€»è¾‘æè¿°ï¼ŒSolutionæ˜¯Projectçš„é›†åˆã€‚ä¸€èˆ¬æ¥è¯´ï¼Œåœ¨ä¸ä½¿ç”¨CMakeæ¨¡æ¿çš„æƒ…å†µä¸‹ï¼Œç¼–è¯‘å’Œé“¾æ¥ä»¥Projectä¸ºå•ä½è¿›è¡Œï¼Œå…¶è¾“å‡ºå¯ä»¥ä¸ºC++å¯æ‰§è¡Œæ–‡ä»¶ï¼Œä¹Ÿå¯ä»¥æ˜¯C++çš„åº“ï¼šé™æ€åº“ï¼ŒåŠ¨æ€é“¾æ¥åº“ã€‚Projectä¹‹é—´å¯ä»¥äº’ç›¸ä¾èµ–ï¼Œå› ä¸ºè¾“å‡ºçš„å¯¹è±¡ä¹‹é—´å¯ä»¥å­˜åœ¨ä¾èµ–å…³ç³»ï¼šæ¯”å¦‚Aé¡¹ç›®ç”Ÿæˆçš„Aå¯æ‰§è¡Œæ–‡ä»¶åœ¨ç¼–è¯‘é˜¶æ®µï¼Œæˆ–è€…è¿è¡Œé˜¶æ®µå°†ä¾èµ–Bé¡¹ç›®ç”Ÿæˆçš„é™æ€åº“ï¼ŒåŠ¨æ€åº“ï¼Œäº¦æˆ–æ˜¯*import library*ã€‚

ä¸€èˆ¬æ¥è¯´ï¼Œå¯¹C++é¡¹ç›®çš„é…ç½®ä¹Ÿæ˜¯ä»¥Projectä¸ºæœ€å°å•ä½è¿›è¡Œçš„ã€‚å³å‡»Projectæ¡ç›®ï¼Œç¨‹åºå‘˜å¯ä»¥æ–¹ä¾¿åœ°ä»¥VSçš„GUIç•Œé¢å¯¹Projectçš„Buildé€‰é¡¹è¿›è¡Œè®¾ç½®ã€‚è¿™äº›å‚æ•°éƒ½ä¼šä»¥é…ç½®æ–‡ä»¶çš„å½¢å¼æŒä¹…åŒ–åœ°å­˜å‚¨åœ¨æœ¬åœ°ã€‚å…¶ä¸­ç¼–è¯‘å™¨é€‰é¡¹ï¼Œinclude file pathï¼Œlinkerçš„æœç´¢è·¯å¾„ï¼Œtargetè®¾ç½®ï¼Œéƒ½æ˜¯éœ€è¦å…³æ³¨çš„é‡ç‚¹ã€‚ä¸€èˆ¬è¿˜æ˜¯å»ºè®®é€šè¿‡GUIå¯¹å·¥ç¨‹é…ç½®è¿›è¡Œè®¾ç½®ï¼Œè€Œä¸æ˜¯ç›´æ¥æ‰“å¼€é…ç½®æ–‡ä»¶ä¿®æ”¹åŠ¨è¾„ä¸Šåƒè¡Œçš„XMLæ–‡ä»¶ã€‚é¡ºä¾¿æä¸€å¥ï¼Œå¦‚æœåœ¨VS installerä¸­å®‰è£…äº†LLVMç›¸å…³çš„å¼€å‘å·¥å…·ï¼Œä½ ä¾¿èƒ½åœ¨é…ç½®é€‰é¡¹ä¸­æ‰¾åˆ°clang-clè¿™ä¸ªä»¥Clangä¸ºå‰ç«¯ï¼ŒWindows MSVCå¹³å°ä¸ºç¼–è¯‘å™¨åç«¯çš„ç¼–è¯‘å™¨ã€‚

## åº“æ–‡ä»¶çš„åˆ†ç±»ä¸import library

åœ¨è¿›è¡Œä¾èµ–åˆ†æä¹‹å‰ï¼Œæˆ‘ä»¬è¦æ˜ç™½ä¾èµ–çš„è¡¨ç°å½¢å¼æ˜¯ä»€ä¹ˆã€‚ä¸€èˆ¬æ¥è¯´ï¼ŒC++ç¨‹åºçš„ä¾èµ–å…³ç³»è¡¨ç°åœ¨ï¼Œå¯æ‰§è¡Œç¨‹åºä¾èµ–åº“ï¼Œåº“å’Œåº“ä¹‹é—´äº’ç›¸ä¾èµ–ã€‚åœ¨Windowsä¸‹ï¼Œé™æ€åº“ä»¥`.lib`ç»“å°¾ï¼ŒåŠ¨æ€åº“ä»¥`.dll`ç»“å°¾ã€‚åœ¨å¾ˆå¤šæ—¶å€™ï¼Œä½ èƒ½çœ‹è§é¡¹ç›®ä¸­å­˜åœ¨åŒåçš„`.lib`å’Œ`.dll`æ–‡ä»¶ï¼Œè¿™å¤§æ¦‚ç‡æ˜¯å› ä¸ºWindowsä¸‹çš„import libraryæœºåˆ¶åœ¨ä½œç¥Ÿã€‚ç®€å•æ¥è¯´ç¨‹åºéœ€è¦åœ¨ç¼–è¯‘é˜¶æ®µå°†åŠ¨æ€åº“å¯¹åº”çš„å¯¼å…¥åº“é“¾æ¥ï¼Œæ‰å¯ä»¥é¡ºåˆ©åœ¨æ‰§è¡Œé˜¶æ®µç”¨åŠ¨æ€é“¾æ¥å™¨ä½¿ç”¨åŠ¨æ€åº“ã€‚è¿™æœ‰ä¸€ç‚¹ç±»ä¼¼C++ç¼–è¯‘é“¾æ¥é˜¶æ®µéœ€è¦includeåº“çš„å¤´æ–‡ä»¶ï¼Œè·åº“çš„ç¬¦å·æ‰èƒ½è®©ç¼–è¯‘å™¨é“¾æ¥å™¨æˆåŠŸç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ã€‚

## ä¾èµ–åˆ†ææ–¹æ³•

å¦‚ä½•åˆ†æä¾èµ–ï¼Ÿå¦‚æœæ˜¯å¸Œæœ›è§£æåŠ¨æ€åº“ä¾èµ–æˆ–è€…å¯æ‰§è¡Œæ–‡ä»¶çš„è¯é‚£å¥½è¯´ï¼Œå¯ä»¥ä½¿ç”¨Dependency Walkeræˆ–è€…Dependenciesè¿™ä¸¤æ¬¾å·¥å…·ã€‚æˆªæ­¢2024å¹´ï¼Œå‰è€…æ”¯æŒä¾èµ–errorçš„æ£€æµ‹ï¼ˆæ¯”å¦‚æ£€æµ‹æ˜¯å¦å­˜åœ¨å¾ªç¯ä¾èµ–ï¼‰ï¼Œâ€œå·ç§°â€èƒ½æœåˆ°å…¨éƒ¨çš„ä¾èµ–ï¼Œæ”¯æŒæŒä¹…åŒ–ï¼Œèƒ½å°†ä¾èµ–å…³ç³»ä»¥æ–‡æœ¬æ ¼å¼ä¿å­˜åœ¨æœ¬åœ°ï¼ˆå¯è¯»æ€§å ªå¿§ï¼‰ã€‚åè€…æ²¡æœ‰ä¸Šè¿°åŠŸèƒ½ï¼Œä½†è§£æé€Ÿåº¦æ˜æ˜¾æ¯”å‰è€…å¿«ä¸å°‘ã€‚æ¯”è¾ƒè®¨åŒçš„æ˜¯Windowsä¸‹åº“æ–‡ä»¶çš„matchè§„åˆ™æ˜¯ä¸åŒºåˆ†å¤§å°å†™çš„ï¼Œåœ¨å†™æŠ¥å‘Šåšæ•´ç†çš„æ—¶å€™éœ€è¦æ‰‹å·¥æ”¹å¤§å°å†™ã€‚

è‡³äºé™æ€åº“çš„ä¾èµ–åˆ†æï¼Œè§£å†³åŠæ³•æ˜¯æŸ¥çœ‹å·¥å…·é“¾é…ç½®æ–‡ä»¶ã€‚é™æ€åº“ç†è®ºä¸Šæ˜¯æ— æ³•é€šè¿‡å¤–éƒ¨ç¬¬ä¸‰æ–¹è§£æè½¯ä»¶è¿›è¡Œè§£æçš„ã€‚è¿™è®©é™æ€åº“å’ŒåŠ¨æ€åº“æ¯”æœ‰å¤©ç„¶çš„å®‰å…¨ä¼˜åŠ¿ï¼ˆå½“ç„¶åŠ£åŠ¿ä¹Ÿå¾ˆæ˜æ˜¾ï¼Œé™æ€ä½“ç§¯ï¼Œæ‰§è¡Œæ—¶å†…å­˜å ç”¨ä½“ç§¯ï¼Œå¢é‡ç¼–è¯‘é€Ÿåº¦etcã€‚ã€‚ã€‚ï¼‰ã€‚åœ¨æ¸¸æˆäº§ä¸šä¸­ï¼Œé™æ€åº“å‘å¸ƒæ˜¯è›®å¸¸è§çš„ï¼Œæ¯•ç«Ÿä¸å¸Œæœ›ä»£ç å®ç°æš´éœ²ç»™é»‘å®¢ã€‚

## Runtime

åœ¨è¿›è¡Œä¾èµ–åˆ†æçš„æ—¶å€™ï¼Œç»å¸¸èƒ½çœ‹è§åº“çš„åå­—ä¸­å«æœ‰*RT*ã€‚ä¸€èˆ¬è¿™æ˜¯*runtime*çš„ç®€ç§°ã€‚Runtimeä¸€èˆ¬æŒ‡ç¨‹åºè¿è¡Œæ—¶æ‰€éœ€è¦çš„ç¯å¢ƒï¼Œä¸€èˆ¬æ¥è¯´C/C++çš„runtimeå°±å¾ˆå°ï¼Œå‘å¸ƒçš„C++ç¨‹åºæ‰€ä¾èµ–çš„åº“æ–‡ä»¶ä¸å¤šï¼Œä½œä¸ºå¯¹æ¯”ï¼ŒGolangå°±éœ€è¦é¢å¤–çš„runtimeæ¥å¸®åŠ©å…¶å®ŒæˆGCæ“ä½œã€‚Kernelä¹Ÿæ˜¯runtimeçš„ä¸€éƒ¨åˆ†ã€‚

## PlantUML

PlantUMLæ˜¯ä¸€æ¬¾ä¸é”™çš„è¡¨ç¤ºä¾èµ–çš„è½¯ä»¶ã€‚ç®€æ´ï¼Œå¯æ‰©å±•ï¼Œæºä»£ç åˆ†ç¦»ï¼Œè‡ªåŠ¨æ’ç‰ˆï¼Œè¿™äº›éƒ½æ˜¯ä»–çš„ä¼˜åŠ¿ã€‚

## Conclusion

ä¾èµ–åˆ†ææ˜¯C++å·¥ç¨‹ç§»æ¤ï¼Œé‡æ„çš„å…ˆå†³æ­¥éª¤ã€‚åœ¨Windowså¹³å°ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨VSçš„GUIç•Œé¢ï¼ŒDependency Walkerï¼ŒDependenciesï¼ŒæŸ¥çœ‹å·¥å…·é“¾é…ç½®æ–‡ä»¶ï¼ŒPlantUMLç­‰å·¥å…·æ¥å¸®åŠ©æˆ‘ä»¬å®Œæˆä¾èµ–åˆ†æã€‚
