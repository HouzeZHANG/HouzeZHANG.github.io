---
title: "Dependency Analysis for Windows C++ Project"
date: 2024-05-05T15:25:57+02:00
draft: false
---

中文在下面👇

## Introduction

When deconstructing and porting complex C++ projects, managing and analyzing project file dependencies are crucial. Online game development involves a myriad of dependencies and library files: from engines to UI; from clients to rendering and media libraries, and network servers. Clarifying the dependency relationships within a project is a prerequisite step for porting and refactoring projects. Trying to undertake porting and refactoring without understanding the dependencies is like a blind person feeling an elephant without knowing where to start.

This article will introduce the methodology and experience I've gained in analyzing dependencies of large and complex C++ projects on the Windows platform.

## Visual Studio's Projects and Solutions

*Projects* and *Solutions* are logical descriptions of C++ modules in Visual Studio (hereinafter referred to as VS), where a Solution is a collection of Projects. Generally, without using CMake templates, compilation and linking are performed at the Project level, and the output can be a C++ executable or a library: static or dynamic. Projects can depend on each other because the objects generated by one Project may depend on objects generated by another Project during compilation or runtime, such as executable A depending on a static or dynamic library generated by Project B or an import library.

Usually, the configuration of C++ projects is done at the Project level. By right-clicking on a Project entry, programmers can easily set Build options for the Project using VS's GUI interface. These parameters are persistently stored locally in configuration files. Key areas of focus include compiler options, include file paths, linker search paths, target settings, etc. It's generally recommended to configure project settings through the GUI rather than directly modifying the XML file, which can be thousands of lines long. By the way, if you have installed LLVM-related development tools in the VS installer, you can find the clang-cl compiler in the configuration options. It uses Clang as the frontend and Windows MSVC platform as the backend compiler.

## Categorization of Library Files and Import Libraries

Before delving into dependency analysis, it's important to understand how dependencies are represented. Typically, in C++ programs, dependencies are manifested in executable programs depending on libraries, and libraries depending on other libraries. In Windows, static libraries end with `.lib`, while dynamic libraries end with `.dll`. Often, you may see files with the same name but different extensions (`.lib` and `.dll`) in a project, which is likely due to the import library mechanism in Windows. In simple terms, during compilation, a program needs to link with the import library corresponding to the dynamic library to be able to use it with the dynamic linker during execution. This is somewhat similar to how C++ compilation and linking require including library header files and symbols to allow the compiler linker to successfully generate executable files.

## Dependency Analysis Methods

How do we analyze dependencies? If you want to resolve dynamic library dependencies or analyze executable files, tools like Dependency Walker or Dependencies can be used. As of 2024, the former supports dependency error detection (such as detecting cyclic dependencies), claims to be able to find all dependencies, supports persistence, and can save dependency relationships in text format locally (though readability may be a concern). The latter does not have the aforementioned features but is noticeably faster in analysis compared to the former. A somewhat annoying aspect is that Windows' library file matching rules are case-insensitive, so manual case modification is required when writing reports or organizing information.

As for static library dependency analysis, the solution is to look at the toolchain configuration files. Static libraries theoretically cannot be analyzed by external third-party software. This distinguishes them from dynamic libraries, which have a natural security advantage (of course, with drawbacks such as static size, memory consumption during execution, incremental compilation speed, etc.). In the gaming industry, releasing static libraries is quite common because you don't want the code implementation to be exposed to hackers.

## Runtime

During dependency analysis, you may often encounter library names containing "RT," which is short for "runtime." Runtime generally refers to the environment needed for a program to run. In the context of C/C++, the runtime is usually small, and the libraries needed for a C++ program's execution are not many. As a comparison, languages like Golang require an additional runtime to assist in garbage collection operations. The kernel is also part of the runtime.

## PlantUML

PlantUML is a good software for representing dependencies. It's concise, extensible, separates source code, and has automatic layout features, which are its advantages.

## Conclusion

Dependency analysis is a prerequisite step for porting and refactoring C++ projects. On the Windows platform, we can use tools such as VS's GUI interface, Dependency Walker, Dependencies, examine toolchain configuration files, and PlantUML to help us perform dependency analysis.

## Introduction

在解构，移植复杂C++工程时，对项目文件的依赖管理与分析至关重要。在线游戏开发涉及千奇百怪的依赖和库文件：下到引擎，上至UI；前有客户端，后有渲染与媒体库与网络服务器。理清项目的依赖关系是对项目进行移植，重构的先决步骤。搞不清楚依赖关系就进行移植和重构，好似盲人摸象无从下手。

这篇文章将介绍我在Windows平台上分析大型复杂C++工程的依赖时的方法论以及经验。

## Visual Studio的Project与Solution

*Project*和*Solution*是*Visual studio*（以下简称VS）对C++模块的逻辑描述，Solution是Project的集合。一般来说，在不使用CMake模板的情况下，编译和链接以Project为单位进行，其输出可以为C++可执行文件，也可以是C++的库：静态库，动态链接库。Project之间可以互相依赖，因为输出的对象之间可以存在依赖关系：比如A项目生成的A可执行文件在编译阶段，或者运行阶段将依赖B项目生成的静态库，动态库，亦或是*import library*。

一般来说，对C++项目的配置也是以Project为最小单位进行的。右击Project条目，程序员可以方便地以VS的GUI界面对Project的Build选项进行设置。这些参数都会以配置文件的形式持久化地存储在本地。其中编译器选项，include file path，linker的搜索路径，target设置，都是需要关注的重点。一般还是建议通过GUI对工程配置进行设置，而不是直接打开配置文件修改动辄上千行的XML文件。顺便提一句，如果在VS installer中安装了LLVM相关的开发工具，你便能在配置选项中找到clang-cl这个以Clang为前端，Windows MSVC平台为编译器后端的编译器。

## 库文件的分类与import library

在进行依赖分析之前，我们要明白依赖的表现形式是什么。一般来说，C++程序的依赖关系表现在，可执行程序依赖库，库和库之间互相依赖。在Windows下，静态库以`.lib`结尾，动态库以`.dll`结尾。在很多时候，你能看见项目中存在同名的`.lib`和`.dll`文件，这大概率是因为Windows下的import library机制在作祟。简单来说程序需要在编译阶段将动态库对应的导入库链接，才可以顺利在执行阶段用动态链接器使用动态库。这有一点类似C++编译链接阶段需要include库的头文件，获库的符号才能让编译器链接器成功生成可执行文件。

## 依赖分析方法

如何分析依赖？如果是希望解析动态库依赖或者可执行文件的话那好说，可以使用Dependency Walker或者Dependencies这两款工具。截止2024年，前者支持依赖error的检测（比如检测是否存在循环依赖），“号称”能搜到全部的依赖，支持持久化，能将依赖关系以文本格式保存在本地（可读性堪忧）。后者没有上述功能，但解析速度明显比前者快不少。比较讨厌的是Windows下库文件的match规则是不区分大小写的，在写报告做整理的时候需要手工改大小写。

至于静态库的依赖分析，解决办法是查看工具链配置文件。静态库理论上是无法通过外部第三方解析软件进行解析的。这让静态库和动态库比有天然的安全优势（当然劣势也很明显，静态体积，执行时内存占用体积，增量编译速度etc。。。）。在游戏产业中，静态库发布是蛮常见的，毕竟不希望代码实现暴露给黑客。

## Runtime

在进行依赖分析的时候，经常能看见库的名字中含有*RT*。一般这是*runtime*的简称。Runtime一般指程序运行时所需要的环境，一般来说C/C++的runtime就很小，发布的C++程序所依赖的库文件不多，作为对比，Golang就需要额外的runtime来帮助其完成GC操作。Kernel也是runtime的一部分。

## PlantUML

PlantUML是一款不错的表示依赖的软件。简洁，可扩展，源代码分离，自动排版，这些都是他的优势。

## Conclusion

依赖分析是C++工程移植，重构的先决步骤。在Windows平台上，我们可以使用VS的GUI界面，Dependency Walker，Dependencies，查看工具链配置文件，PlantUML等工具来帮助我们完成依赖分析。
