---
title: "Rust from scratch L1: Hello world, variables, scalars and compound types"
date: 2025-12-18T17:12:00+01:00
slug: 2025-12-18-l1
type: posts
draft: false
categories:
  - "Computer Science"
tags: ["Rust"]
---

In this article at least two safety features of Rust are demonstrated: overflow check and immutability by default. C++ also has tuples. The access of tuple elements is different in Rust and C++.

---

## Toolchain

Rust uses `cargo` and `rustc`. Cargo is the package manager, people also use it for compilation. Rustc is the compiler.

Compile and run the program:

```bash
cargo run --bin <binary-name>
```

Compile the release version, which will **ignore debug info such as integer overflow checks**:

```bash
cargo build --bin <binary-name> --release
```

Format the code:

```bash
cargo fmt
```

## Hello world in Rust

```rust
fn main() {
    println!("Hello, world!");
}
```

## Formatting print statements

```rust
fn main() {
    let name = "Alice";
    println!("Hello, {}!", name); // Positional
    println!("Hello, {name}!"); // Named
    println!("Hello, {0}, meet {1}. {1}, meet {0}.", "Alice", "Bob"); // Positional with indices
}
```

## Debug mode

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 10, y: 20 };
    println!("Point: {:?}", point); // Debug print
    println!("Point: {:#?}", point); // Pretty debug print
}
```

## Variables and Mutability

By default, variables are immutable. Use `mut` to make them mutable.

```rust
fn main() {
    let x: i32 = 5; // Immutable
    // x = 6; // Error: cannot assign twice to immutable variable

    let mut y: i32 = 10; // Mutable
    y = 15; // OK
    println!("x: {}, y: {}", x, y);
}
```

Rust support type inference, integer types default to `i32`.

```rust
fn main() {
    let x = 5; // Type inferred as i32
    let mut y = 10; // Type inferred as i32
}
```

Type inference for vectors.

```rust
fn main() {
    let v: Vec<_> = vec![1, 2, 3]; // Explicit type
}
```

Const in Rust.

```rust
const MAX_POINTS: u32 = 100_000; // Constants are always immutable and must have a type annotation
```

Shadowing.

```rust
fn main() {
    let x: i32 = 5;
    let x: bool = true; // Shadowing with a new type
}
```

## Scalar Types

Scalar types are building block for complex data types:

- Integers
- Floating-point numbers
- Booleans
- Characters

Integer types in Rust:

```rust
let i0: i8 = 0;
let i1: i16 = 1;
let i3: i32 = 1;
let i4: i128 = 1;
// depends on the computer arch
let i5: isize = 1;

let u0: u8 = 1;
let u1: u16 = 1;
let u2: u32 = 1;
let u3: u64 = 1;
let u4: u128 = 1;
let u5: usize = 1;
```

Floating-point types:

```rust
let f0: f32 = 0.01;
let f1: f64 = 0.01;
```

Character type:

```rust
let c: char = 'c';
let e: char = 'ðŸ¦€';
```

Boolean type:

```rust
let t: bool = true;
let f: bool = false;
```

Min and max values:

```rust
fn main() {
    println!("i8 min: {}, max: {}", i8::MIN, i8::MAX);
    println!("u8 min: {}, max: {}", u8::MIN, u8::MAX);
}
```

## Overflow

In debug mode, integer overflow will cause a panic at runtime.

```rust
fn main() {
    let x: u8 = u8::MAX;
    let y = x + 1; // Panic in debug mode
}
```

Use `checked_add` to handle overflow, if overflow occurs, it returns `None`.

```rust
fn main() {
    let x: u8 = u8::MAX;
    u8::checked_add(x, 1); // Returns None
}
```

Use `wrapping_add` to wrap around on overflow, wraps around the number. This is useful to force the behavior of overflow, otherwise compiler will handle the overflow in its own way, basing on optimization level.

```rust
fn main() {
    let u: u32 = u32::wrapping_add(u32::MAX, 1); // u = 0
}
```

## Tuples

Tuples group multiple values of different types into one compound type. Function can return tuples.

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!("x: {}, y: {}, z: {}", x, y, z);
```

Nested tuples is supported. Should use dot notation to access elements.

```rust
fn main() {
    let nested_tup: ((i32, f64), u8) = ((500, 6.4), 1);
    println!("nested_tup: (({}, {}), {})", (nested_tup.0).0, (nested_tup.0).1, nested_tup.1);
}
```
